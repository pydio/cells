// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.1.0
// - protoc             (unknown)
// source: cells-chat.proto

package chat

import (
	context "context"
	fmt "fmt"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	metadata "google.golang.org/grpc/metadata"
	status "google.golang.org/grpc/status"
	sync "sync"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

var (
	enhancedChatServiceServers     = make(map[string]ChatServiceEnhancedServer)
	enhancedChatServiceServersLock = sync.RWMutex{}
)

type NamedChatServiceServer interface {
	ChatServiceServer
	Name() string
}
type ChatServiceEnhancedServer map[string]NamedChatServiceServer

func (m ChatServiceEnhancedServer) PutRoom(ctx context.Context, r *PutRoomRequest) (*PutRoomResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method PutRoom should have a context")
	}
	enhancedChatServiceServersLock.RLock()
	defer enhancedChatServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.PutRoom(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method PutRoom not implemented")
}

func (m ChatServiceEnhancedServer) DeleteRoom(ctx context.Context, r *DeleteRoomRequest) (*DeleteRoomResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method DeleteRoom should have a context")
	}
	enhancedChatServiceServersLock.RLock()
	defer enhancedChatServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.DeleteRoom(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRoom not implemented")
}

func (m ChatServiceEnhancedServer) ListRooms(r *ListRoomsRequest, s ChatService_ListRoomsServer) error {
	md, ok := metadata.FromIncomingContext(s.Context())
	if !ok || len(md.Get("targetname")) == 0 {
		return status.Errorf(codes.FailedPrecondition, "method ListRooms should have a context")
	}
	enhancedChatServiceServersLock.RLock()
	defer enhancedChatServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.ListRooms(r, s)
		}
	}
	return status.Errorf(codes.Unimplemented, "method ListRooms not implemented")
}

func (m ChatServiceEnhancedServer) ListMessages(r *ListMessagesRequest, s ChatService_ListMessagesServer) error {
	md, ok := metadata.FromIncomingContext(s.Context())
	if !ok || len(md.Get("targetname")) == 0 {
		return status.Errorf(codes.FailedPrecondition, "method ListMessages should have a context")
	}
	enhancedChatServiceServersLock.RLock()
	defer enhancedChatServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.ListMessages(r, s)
		}
	}
	return status.Errorf(codes.Unimplemented, "method ListMessages not implemented")
}

func (m ChatServiceEnhancedServer) PostMessage(ctx context.Context, r *PostMessageRequest) (*PostMessageResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method PostMessage should have a context")
	}
	enhancedChatServiceServersLock.RLock()
	defer enhancedChatServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.PostMessage(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method PostMessage not implemented")
}

func (m ChatServiceEnhancedServer) DeleteMessage(ctx context.Context, r *DeleteMessageRequest) (*DeleteMessageResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method DeleteMessage should have a context")
	}
	enhancedChatServiceServersLock.RLock()
	defer enhancedChatServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.DeleteMessage(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMessage not implemented")
}
func (m ChatServiceEnhancedServer) mustEmbedUnimplementedChatServiceServer() {}
func RegisterChatServiceEnhancedServer(s grpc.ServiceRegistrar, srv NamedChatServiceServer) {
	enhancedChatServiceServersLock.Lock()
	defer enhancedChatServiceServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedChatServiceServers[addr]
	if !ok {
		m = ChatServiceEnhancedServer{}
		enhancedChatServiceServers[addr] = m
		RegisterChatServiceServer(s, m)
	}
	m[srv.Name()] = srv
}
func DeregisterChatServiceEnhancedServer(s grpc.ServiceRegistrar, name string) {
	enhancedChatServiceServersLock.Lock()
	defer enhancedChatServiceServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedChatServiceServers[addr]
	if !ok {
		return
	}
	delete(m, name)
}
