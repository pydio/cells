// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.1.0
// - protoc             v3.18.1
// source: cells-jobs.proto

package jobs

import (
	context "context"
	fmt "fmt"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	metadata "google.golang.org/grpc/metadata"
	status "google.golang.org/grpc/status"
	sync "sync"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

var (
	enhancedJobServiceServers     = make(map[string]JobServiceEnhancedServer)
	enhancedJobServiceServersLock = sync.RWMutex{}
)

type NamedJobServiceServer interface {
	JobServiceServer
	Name() string
}
type JobServiceEnhancedServer map[string]NamedJobServiceServer

func (m JobServiceEnhancedServer) PutJob(ctx context.Context, r *PutJobRequest) (*PutJobResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method PutJob should have a context")
	}
	enhancedJobServiceServersLock.RLock()
	defer enhancedJobServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.PutJob(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method PutJob not implemented")
}

func (m JobServiceEnhancedServer) GetJob(ctx context.Context, r *GetJobRequest) (*GetJobResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method GetJob should have a context")
	}
	enhancedJobServiceServersLock.RLock()
	defer enhancedJobServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.GetJob(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method GetJob not implemented")
}

func (m JobServiceEnhancedServer) DeleteJob(ctx context.Context, r *DeleteJobRequest) (*DeleteJobResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method DeleteJob should have a context")
	}
	enhancedJobServiceServersLock.RLock()
	defer enhancedJobServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.DeleteJob(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method DeleteJob not implemented")
}

func (m JobServiceEnhancedServer) ListJobs(r *ListJobsRequest, s JobService_ListJobsServer) error {
	md, ok := metadata.FromIncomingContext(s.Context())
	if !ok || len(md.Get("targetname")) == 0 {
		return status.Errorf(codes.FailedPrecondition, "method ListJobs should have a context")
	}
	enhancedJobServiceServersLock.RLock()
	defer enhancedJobServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.ListJobs(r, s)
		}
	}
	return status.Errorf(codes.Unimplemented, "method ListJobs not implemented")
}

func (m JobServiceEnhancedServer) PutTask(ctx context.Context, r *PutTaskRequest) (*PutTaskResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method PutTask should have a context")
	}
	enhancedJobServiceServersLock.RLock()
	defer enhancedJobServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.PutTask(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method PutTask not implemented")
}

func (m JobServiceEnhancedServer) PutTaskStream(s JobService_PutTaskStreamServer) error {
	md, ok := metadata.FromIncomingContext(s.Context())
	if !ok || len(md.Get("targetname")) == 0 {
		return status.Errorf(codes.FailedPrecondition, "method PutTaskStream should have a context")
	}
	enhancedJobServiceServersLock.RLock()
	defer enhancedJobServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.PutTaskStream(s)
		}
	}
	return status.Errorf(codes.Unimplemented, "method PutTaskStream not implemented")
}

func (m JobServiceEnhancedServer) ListTasks(r *ListTasksRequest, s JobService_ListTasksServer) error {
	md, ok := metadata.FromIncomingContext(s.Context())
	if !ok || len(md.Get("targetname")) == 0 {
		return status.Errorf(codes.FailedPrecondition, "method ListTasks should have a context")
	}
	enhancedJobServiceServersLock.RLock()
	defer enhancedJobServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.ListTasks(r, s)
		}
	}
	return status.Errorf(codes.Unimplemented, "method ListTasks not implemented")
}

func (m JobServiceEnhancedServer) DeleteTasks(ctx context.Context, r *DeleteTasksRequest) (*DeleteTasksResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method DeleteTasks should have a context")
	}
	enhancedJobServiceServersLock.RLock()
	defer enhancedJobServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.DeleteTasks(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTasks not implemented")
}

func (m JobServiceEnhancedServer) DetectStuckTasks(ctx context.Context, r *DetectStuckTasksRequest) (*DetectStuckTasksResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method DetectStuckTasks should have a context")
	}
	enhancedJobServiceServersLock.RLock()
	defer enhancedJobServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.DetectStuckTasks(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method DetectStuckTasks not implemented")
}
func (m JobServiceEnhancedServer) mustEmbedUnimplementedJobServiceServer() {}
func RegisterJobServiceEnhancedServer(s grpc.ServiceRegistrar, srv NamedJobServiceServer) {
	enhancedJobServiceServersLock.Lock()
	defer enhancedJobServiceServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedJobServiceServers[addr]
	if !ok {
		m = JobServiceEnhancedServer{}
		enhancedJobServiceServers[addr] = m
		RegisterJobServiceServer(s, m)
	}
	m[srv.Name()] = srv
}
func DeregisterJobServiceEnhancedServer(s grpc.ServiceRegistrar, name string) {
	enhancedJobServiceServersLock.Lock()
	defer enhancedJobServiceServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedJobServiceServers[addr]
	if !ok {
		return
	}
	delete(m, name)
}

var (
	enhancedTaskServiceServers     = make(map[string]TaskServiceEnhancedServer)
	enhancedTaskServiceServersLock = sync.RWMutex{}
)

type NamedTaskServiceServer interface {
	TaskServiceServer
	Name() string
}
type TaskServiceEnhancedServer map[string]NamedTaskServiceServer

func (m TaskServiceEnhancedServer) Control(ctx context.Context, r *CtrlCommand) (*CtrlCommandResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method Control should have a context")
	}
	enhancedTaskServiceServersLock.RLock()
	defer enhancedTaskServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.Control(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method Control not implemented")
}
func (m TaskServiceEnhancedServer) mustEmbedUnimplementedTaskServiceServer() {}
func RegisterTaskServiceEnhancedServer(s grpc.ServiceRegistrar, srv NamedTaskServiceServer) {
	enhancedTaskServiceServersLock.Lock()
	defer enhancedTaskServiceServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedTaskServiceServers[addr]
	if !ok {
		m = TaskServiceEnhancedServer{}
		enhancedTaskServiceServers[addr] = m
		RegisterTaskServiceServer(s, m)
	}
	m[srv.Name()] = srv
}
func DeregisterTaskServiceEnhancedServer(s grpc.ServiceRegistrar, name string) {
	enhancedTaskServiceServersLock.Lock()
	defer enhancedTaskServiceServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedTaskServiceServers[addr]
	if !ok {
		return
	}
	delete(m, name)
}
