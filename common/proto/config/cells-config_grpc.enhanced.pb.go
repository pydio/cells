// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.1.0
// - protoc             (unknown)
// source: cells-config.proto

package config

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	metadata "google.golang.org/grpc/metadata"
	status "google.golang.org/grpc/status"
	strings "strings"
	sync "sync"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

var (
	enhancedConfigServers     = make(map[string]ConfigEnhancedServer)
	enhancedConfigServersLock = sync.RWMutex{}
)

type NamedConfigServer interface {
	ConfigServer
	Name() string
}
type ConfigEnhancedServer map[string]NamedConfigServer

func (m ConfigEnhancedServer) Get(ctx context.Context, r *GetRequest) (*GetResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method Get should have a context")
	}
	enhancedConfigServersLock.RLock()
	defer enhancedConfigServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.Get(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}

func (m ConfigEnhancedServer) Set(ctx context.Context, r *SetRequest) (*SetResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method Set should have a context")
	}
	enhancedConfigServersLock.RLock()
	defer enhancedConfigServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.Set(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}

func (m ConfigEnhancedServer) Delete(ctx context.Context, r *DeleteRequest) (*DeleteResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method Delete should have a context")
	}
	enhancedConfigServersLock.RLock()
	defer enhancedConfigServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.Delete(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}

func (m ConfigEnhancedServer) Watch(r *WatchRequest, s Config_WatchServer) error {
	md, ok := metadata.FromIncomingContext(s.Context())
	if !ok || len(md.Get("targetname")) == 0 {
		return status.Errorf(codes.FailedPrecondition, "method Watch should have a context")
	}
	enhancedConfigServersLock.RLock()
	defer enhancedConfigServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.Watch(r, s)
		}
	}
	return status.Errorf(codes.Unimplemented, "method Watch not implemented")
}

func (m ConfigEnhancedServer) Save(ctx context.Context, r *SaveRequest) (*SaveResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method Save should have a context")
	}
	enhancedConfigServersLock.RLock()
	defer enhancedConfigServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.Save(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method Save not implemented")
}
func (m ConfigEnhancedServer) mustEmbedUnimplementedConfigServer() {}
func RegisterConfigEnhancedServer(s grpc.ServiceRegistrar, srv NamedConfigServer) {
	serviceDesc := Config_ServiceDesc
	serviceDesc.ServiceName = strings.Join([]string{srv.Name(), serviceDesc.ServiceName}, ".")
	s.RegisterService(&serviceDesc, srv)
}
