// Code generated by protoc-gen-go. DO NOT EDIT.
// source: data.proto

package rest

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import tree "github.com/pydio/cells/common/proto/tree"
import docstore "github.com/pydio/cells/common/proto/docstore"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type SearchResults struct {
	Results []*tree.Node `protobuf:"bytes,1,rep,name=Results" json:"Results,omitempty"`
	Total   int32        `protobuf:"varint,2,opt,name=Total" json:"Total,omitempty"`
}

func (m *SearchResults) Reset()                    { *m = SearchResults{} }
func (m *SearchResults) String() string            { return proto.CompactTextString(m) }
func (*SearchResults) ProtoMessage()               {}
func (*SearchResults) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{0} }

func (m *SearchResults) GetResults() []*tree.Node {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *SearchResults) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

// Generic container for responses sending pagination information
type Pagination struct {
	// Current Limit parameter, either passed by request or default value
	Limit int32 `protobuf:"varint,1,opt,name=Limit" json:"Limit,omitempty"`
	// Current Offset value
	CurrentOffset int32 `protobuf:"varint,2,opt,name=CurrentOffset" json:"CurrentOffset,omitempty"`
	// Total number of records
	Total int32 `protobuf:"varint,3,opt,name=Total" json:"Total,omitempty"`
	// Current number of Page
	CurrentPage int32 `protobuf:"varint,4,opt,name=CurrentPage" json:"CurrentPage,omitempty"`
	// Number of detected pages
	TotalPages int32 `protobuf:"varint,5,opt,name=TotalPages" json:"TotalPages,omitempty"`
	// Offset value for next page if there is one
	NextOffset int32 `protobuf:"varint,6,opt,name=NextOffset" json:"NextOffset,omitempty"`
	// Offset value for previous page, if there is one
	PrevOffset int32 `protobuf:"varint,7,opt,name=PrevOffset" json:"PrevOffset,omitempty"`
}

func (m *Pagination) Reset()                    { *m = Pagination{} }
func (m *Pagination) String() string            { return proto.CompactTextString(m) }
func (*Pagination) ProtoMessage()               {}
func (*Pagination) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{1} }

func (m *Pagination) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *Pagination) GetCurrentOffset() int32 {
	if m != nil {
		return m.CurrentOffset
	}
	return 0
}

func (m *Pagination) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *Pagination) GetCurrentPage() int32 {
	if m != nil {
		return m.CurrentPage
	}
	return 0
}

func (m *Pagination) GetTotalPages() int32 {
	if m != nil {
		return m.TotalPages
	}
	return 0
}

func (m *Pagination) GetNextOffset() int32 {
	if m != nil {
		return m.NextOffset
	}
	return 0
}

func (m *Pagination) GetPrevOffset() int32 {
	if m != nil {
		return m.PrevOffset
	}
	return 0
}

type Metadata struct {
	Namespace string `protobuf:"bytes,1,opt,name=Namespace" json:"Namespace,omitempty"`
	JsonMeta  string `protobuf:"bytes,2,opt,name=JsonMeta" json:"JsonMeta,omitempty"`
}

func (m *Metadata) Reset()                    { *m = Metadata{} }
func (m *Metadata) String() string            { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()               {}
func (*Metadata) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{2} }

func (m *Metadata) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Metadata) GetJsonMeta() string {
	if m != nil {
		return m.JsonMeta
	}
	return ""
}

type MetaCollection struct {
	NodePath  string      `protobuf:"bytes,1,opt,name=NodePath" json:"NodePath,omitempty"`
	Metadatas []*Metadata `protobuf:"bytes,2,rep,name=Metadatas" json:"Metadatas,omitempty"`
}

func (m *MetaCollection) Reset()                    { *m = MetaCollection{} }
func (m *MetaCollection) String() string            { return proto.CompactTextString(m) }
func (*MetaCollection) ProtoMessage()               {}
func (*MetaCollection) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{3} }

func (m *MetaCollection) GetNodePath() string {
	if m != nil {
		return m.NodePath
	}
	return ""
}

func (m *MetaCollection) GetMetadatas() []*Metadata {
	if m != nil {
		return m.Metadatas
	}
	return nil
}

type MetaNamespaceRequest struct {
	// Path to the requested node
	NodePath string `protobuf:"bytes,1,opt,name=NodePath" json:"NodePath,omitempty"`
	// List of namespaces to load
	Namespace []string `protobuf:"bytes,2,rep,name=Namespace" json:"Namespace,omitempty"`
}

func (m *MetaNamespaceRequest) Reset()                    { *m = MetaNamespaceRequest{} }
func (m *MetaNamespaceRequest) String() string            { return proto.CompactTextString(m) }
func (*MetaNamespaceRequest) ProtoMessage()               {}
func (*MetaNamespaceRequest) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{4} }

func (m *MetaNamespaceRequest) GetNodePath() string {
	if m != nil {
		return m.NodePath
	}
	return ""
}

func (m *MetaNamespaceRequest) GetNamespace() []string {
	if m != nil {
		return m.Namespace
	}
	return nil
}

type GetBulkMetaRequest struct {
	// List of node paths to query (use paths ending with /* to load the children)
	NodePaths []string `protobuf:"bytes,1,rep,name=NodePaths" json:"NodePaths,omitempty"`
	// List of nodes based on their Uuids
	NodeUuids []string `protobuf:"bytes,2,rep,name=NodeUuids" json:"NodeUuids,omitempty"`
	// Whether to query all services for the metadata they can contribute to enrich the node
	AllMetaProviders bool `protobuf:"varint,3,opt,name=AllMetaProviders" json:"AllMetaProviders,omitempty"`
	// Load Versions of the given node
	Versions bool `protobuf:"varint,4,opt,name=Versions" json:"Versions,omitempty"`
	// Start listing at a given position
	Offset int32 `protobuf:"varint,5,opt,name=Offset" json:"Offset,omitempty"`
	// Limit number of results
	Limit int32 `protobuf:"varint,6,opt,name=Limit" json:"Limit,omitempty"`
}

func (m *GetBulkMetaRequest) Reset()                    { *m = GetBulkMetaRequest{} }
func (m *GetBulkMetaRequest) String() string            { return proto.CompactTextString(m) }
func (*GetBulkMetaRequest) ProtoMessage()               {}
func (*GetBulkMetaRequest) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{5} }

func (m *GetBulkMetaRequest) GetNodePaths() []string {
	if m != nil {
		return m.NodePaths
	}
	return nil
}

func (m *GetBulkMetaRequest) GetNodeUuids() []string {
	if m != nil {
		return m.NodeUuids
	}
	return nil
}

func (m *GetBulkMetaRequest) GetAllMetaProviders() bool {
	if m != nil {
		return m.AllMetaProviders
	}
	return false
}

func (m *GetBulkMetaRequest) GetVersions() bool {
	if m != nil {
		return m.Versions
	}
	return false
}

func (m *GetBulkMetaRequest) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *GetBulkMetaRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type BulkMetaResponse struct {
	Nodes      []*tree.Node `protobuf:"bytes,1,rep,name=Nodes" json:"Nodes,omitempty"`
	Pagination *Pagination  `protobuf:"bytes,5,opt,name=Pagination" json:"Pagination,omitempty"`
}

func (m *BulkMetaResponse) Reset()                    { *m = BulkMetaResponse{} }
func (m *BulkMetaResponse) String() string            { return proto.CompactTextString(m) }
func (*BulkMetaResponse) ProtoMessage()               {}
func (*BulkMetaResponse) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{6} }

func (m *BulkMetaResponse) GetNodes() []*tree.Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *BulkMetaResponse) GetPagination() *Pagination {
	if m != nil {
		return m.Pagination
	}
	return nil
}

type HeadNodeRequest struct {
	// The node to state
	Node string `protobuf:"bytes,1,opt,name=Node" json:"Node,omitempty"`
}

func (m *HeadNodeRequest) Reset()                    { *m = HeadNodeRequest{} }
func (m *HeadNodeRequest) String() string            { return proto.CompactTextString(m) }
func (*HeadNodeRequest) ProtoMessage()               {}
func (*HeadNodeRequest) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{7} }

func (m *HeadNodeRequest) GetNode() string {
	if m != nil {
		return m.Node
	}
	return ""
}

type HeadNodeResponse struct {
	Node *tree.Node `protobuf:"bytes,1,opt,name=Node" json:"Node,omitempty"`
}

func (m *HeadNodeResponse) Reset()                    { *m = HeadNodeResponse{} }
func (m *HeadNodeResponse) String() string            { return proto.CompactTextString(m) }
func (*HeadNodeResponse) ProtoMessage()               {}
func (*HeadNodeResponse) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{8} }

func (m *HeadNodeResponse) GetNode() *tree.Node {
	if m != nil {
		return m.Node
	}
	return nil
}

type CreateNodesRequest struct {
	// A list of nodes that must be created
	Nodes []*tree.Node `protobuf:"bytes,1,rep,name=Nodes" json:"Nodes,omitempty"`
	// If nodes are created inside non-existing folders, whether the parents should be created automatically or not
	Recursive bool `protobuf:"varint,2,opt,name=Recursive" json:"Recursive,omitempty"`
	// Use a template to create this node
	TemplateUUID string `protobuf:"bytes,3,opt,name=TemplateUUID" json:"TemplateUUID,omitempty"`
}

func (m *CreateNodesRequest) Reset()                    { *m = CreateNodesRequest{} }
func (m *CreateNodesRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateNodesRequest) ProtoMessage()               {}
func (*CreateNodesRequest) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{9} }

func (m *CreateNodesRequest) GetNodes() []*tree.Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *CreateNodesRequest) GetRecursive() bool {
	if m != nil {
		return m.Recursive
	}
	return false
}

func (m *CreateNodesRequest) GetTemplateUUID() string {
	if m != nil {
		return m.TemplateUUID
	}
	return ""
}

type CreateSelectionRequest struct {
	// Create a temporary selection out of this list of nodes
	Nodes []*tree.Node `protobuf:"bytes,1,rep,name=Nodes" json:"Nodes,omitempty"`
	// Associated target action for this selection
	TargetAction string `protobuf:"bytes,2,opt,name=TargetAction" json:"TargetAction,omitempty"`
	// Whether to save the selection or just get a temporary Uuid in return
	Persist bool `protobuf:"varint,3,opt,name=Persist" json:"Persist,omitempty"`
}

func (m *CreateSelectionRequest) Reset()                    { *m = CreateSelectionRequest{} }
func (m *CreateSelectionRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateSelectionRequest) ProtoMessage()               {}
func (*CreateSelectionRequest) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{10} }

func (m *CreateSelectionRequest) GetNodes() []*tree.Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *CreateSelectionRequest) GetTargetAction() string {
	if m != nil {
		return m.TargetAction
	}
	return ""
}

func (m *CreateSelectionRequest) GetPersist() bool {
	if m != nil {
		return m.Persist
	}
	return false
}

type CreateSelectionResponse struct {
	SelectionUUID string       `protobuf:"bytes,1,opt,name=SelectionUUID" json:"SelectionUUID,omitempty"`
	Nodes         []*tree.Node `protobuf:"bytes,2,rep,name=Nodes" json:"Nodes,omitempty"`
}

func (m *CreateSelectionResponse) Reset()                    { *m = CreateSelectionResponse{} }
func (m *CreateSelectionResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateSelectionResponse) ProtoMessage()               {}
func (*CreateSelectionResponse) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{11} }

func (m *CreateSelectionResponse) GetSelectionUUID() string {
	if m != nil {
		return m.SelectionUUID
	}
	return ""
}

func (m *CreateSelectionResponse) GetNodes() []*tree.Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type NodesCollection struct {
	Parent   *tree.Node   `protobuf:"bytes,1,opt,name=Parent" json:"Parent,omitempty"`
	Children []*tree.Node `protobuf:"bytes,2,rep,name=Children" json:"Children,omitempty"`
}

func (m *NodesCollection) Reset()                    { *m = NodesCollection{} }
func (m *NodesCollection) String() string            { return proto.CompactTextString(m) }
func (*NodesCollection) ProtoMessage()               {}
func (*NodesCollection) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{12} }

func (m *NodesCollection) GetParent() *tree.Node {
	if m != nil {
		return m.Parent
	}
	return nil
}

func (m *NodesCollection) GetChildren() []*tree.Node {
	if m != nil {
		return m.Children
	}
	return nil
}

type DeleteNodesRequest struct {
	// List of nodes to delete
	Nodes []*tree.Node `protobuf:"bytes,1,rep,name=Nodes" json:"Nodes,omitempty"`
	// Whether to delete all the children if node is a folder
	Recursive bool `protobuf:"varint,2,opt,name=Recursive" json:"Recursive,omitempty"`
}

func (m *DeleteNodesRequest) Reset()                    { *m = DeleteNodesRequest{} }
func (m *DeleteNodesRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteNodesRequest) ProtoMessage()               {}
func (*DeleteNodesRequest) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{13} }

func (m *DeleteNodesRequest) GetNodes() []*tree.Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *DeleteNodesRequest) GetRecursive() bool {
	if m != nil {
		return m.Recursive
	}
	return false
}

type BackgroundJobResult struct {
	Uuid     string `protobuf:"bytes,1,opt,name=Uuid" json:"Uuid,omitempty"`
	Label    string `protobuf:"bytes,2,opt,name=Label" json:"Label,omitempty"`
	NodeUuid string `protobuf:"bytes,3,opt,name=NodeUuid" json:"NodeUuid,omitempty"`
}

func (m *BackgroundJobResult) Reset()                    { *m = BackgroundJobResult{} }
func (m *BackgroundJobResult) String() string            { return proto.CompactTextString(m) }
func (*BackgroundJobResult) ProtoMessage()               {}
func (*BackgroundJobResult) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{14} }

func (m *BackgroundJobResult) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *BackgroundJobResult) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *BackgroundJobResult) GetNodeUuid() string {
	if m != nil {
		return m.NodeUuid
	}
	return ""
}

type DeleteNodesResponse struct {
	DeleteJobs []*BackgroundJobResult `protobuf:"bytes,1,rep,name=DeleteJobs" json:"DeleteJobs,omitempty"`
}

func (m *DeleteNodesResponse) Reset()                    { *m = DeleteNodesResponse{} }
func (m *DeleteNodesResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteNodesResponse) ProtoMessage()               {}
func (*DeleteNodesResponse) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{15} }

func (m *DeleteNodesResponse) GetDeleteJobs() []*BackgroundJobResult {
	if m != nil {
		return m.DeleteJobs
	}
	return nil
}

type RestoreNodesRequest struct {
	// Restore this node from the recycle bin to its original location
	Nodes []*tree.Node `protobuf:"bytes,1,rep,name=Nodes" json:"Nodes,omitempty"`
}

func (m *RestoreNodesRequest) Reset()                    { *m = RestoreNodesRequest{} }
func (m *RestoreNodesRequest) String() string            { return proto.CompactTextString(m) }
func (*RestoreNodesRequest) ProtoMessage()               {}
func (*RestoreNodesRequest) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{16} }

func (m *RestoreNodesRequest) GetNodes() []*tree.Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type RestoreNodesResponse struct {
	RestoreJobs []*BackgroundJobResult `protobuf:"bytes,1,rep,name=RestoreJobs" json:"RestoreJobs,omitempty"`
}

func (m *RestoreNodesResponse) Reset()                    { *m = RestoreNodesResponse{} }
func (m *RestoreNodesResponse) String() string            { return proto.CompactTextString(m) }
func (*RestoreNodesResponse) ProtoMessage()               {}
func (*RestoreNodesResponse) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{17} }

func (m *RestoreNodesResponse) GetRestoreJobs() []*BackgroundJobResult {
	if m != nil {
		return m.RestoreJobs
	}
	return nil
}

type ListDocstoreRequest struct {
	// Id of the Store to list
	StoreID string `protobuf:"bytes,1,opt,name=StoreID" json:"StoreID,omitempty"`
	// Bleve-query for searching the store
	Query *docstore.DocumentQuery `protobuf:"bytes,2,opt,name=Query" json:"Query,omitempty"`
	// Return only the number of results, no actual documents
	CountOnly bool `protobuf:"varint,3,opt,name=CountOnly" json:"CountOnly,omitempty"`
}

func (m *ListDocstoreRequest) Reset()                    { *m = ListDocstoreRequest{} }
func (m *ListDocstoreRequest) String() string            { return proto.CompactTextString(m) }
func (*ListDocstoreRequest) ProtoMessage()               {}
func (*ListDocstoreRequest) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{18} }

func (m *ListDocstoreRequest) GetStoreID() string {
	if m != nil {
		return m.StoreID
	}
	return ""
}

func (m *ListDocstoreRequest) GetQuery() *docstore.DocumentQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *ListDocstoreRequest) GetCountOnly() bool {
	if m != nil {
		return m.CountOnly
	}
	return false
}

type DocstoreCollection struct {
	Docs  []*docstore.Document `protobuf:"bytes,1,rep,name=Docs" json:"Docs,omitempty"`
	Total int64                `protobuf:"varint,2,opt,name=Total" json:"Total,omitempty"`
}

func (m *DocstoreCollection) Reset()                    { *m = DocstoreCollection{} }
func (m *DocstoreCollection) String() string            { return proto.CompactTextString(m) }
func (*DocstoreCollection) ProtoMessage()               {}
func (*DocstoreCollection) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{19} }

func (m *DocstoreCollection) GetDocs() []*docstore.Document {
	if m != nil {
		return m.Docs
	}
	return nil
}

func (m *DocstoreCollection) GetTotal() int64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func init() {
	proto.RegisterType((*SearchResults)(nil), "rest.SearchResults")
	proto.RegisterType((*Pagination)(nil), "rest.Pagination")
	proto.RegisterType((*Metadata)(nil), "rest.Metadata")
	proto.RegisterType((*MetaCollection)(nil), "rest.MetaCollection")
	proto.RegisterType((*MetaNamespaceRequest)(nil), "rest.MetaNamespaceRequest")
	proto.RegisterType((*GetBulkMetaRequest)(nil), "rest.GetBulkMetaRequest")
	proto.RegisterType((*BulkMetaResponse)(nil), "rest.BulkMetaResponse")
	proto.RegisterType((*HeadNodeRequest)(nil), "rest.HeadNodeRequest")
	proto.RegisterType((*HeadNodeResponse)(nil), "rest.HeadNodeResponse")
	proto.RegisterType((*CreateNodesRequest)(nil), "rest.CreateNodesRequest")
	proto.RegisterType((*CreateSelectionRequest)(nil), "rest.CreateSelectionRequest")
	proto.RegisterType((*CreateSelectionResponse)(nil), "rest.CreateSelectionResponse")
	proto.RegisterType((*NodesCollection)(nil), "rest.NodesCollection")
	proto.RegisterType((*DeleteNodesRequest)(nil), "rest.DeleteNodesRequest")
	proto.RegisterType((*BackgroundJobResult)(nil), "rest.BackgroundJobResult")
	proto.RegisterType((*DeleteNodesResponse)(nil), "rest.DeleteNodesResponse")
	proto.RegisterType((*RestoreNodesRequest)(nil), "rest.RestoreNodesRequest")
	proto.RegisterType((*RestoreNodesResponse)(nil), "rest.RestoreNodesResponse")
	proto.RegisterType((*ListDocstoreRequest)(nil), "rest.ListDocstoreRequest")
	proto.RegisterType((*DocstoreCollection)(nil), "rest.DocstoreCollection")
}

func init() { proto.RegisterFile("data.proto", fileDescriptor3) }

var fileDescriptor3 = []byte{
	// 839 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0x5f, 0x6f, 0x1b, 0x45,
	0x10, 0x97, 0x93, 0xd8, 0xb1, 0xc7, 0xb4, 0x8d, 0x36, 0x51, 0x7b, 0x44, 0x55, 0x15, 0xad, 0x42,
	0x55, 0x21, 0xb0, 0x91, 0xfb, 0x80, 0x50, 0x9f, 0x5a, 0x5b, 0x02, 0x42, 0x49, 0x8f, 0x75, 0xc2,
	0x03, 0x88, 0x87, 0xf5, 0xdd, 0xc4, 0x3e, 0xe5, 0x7c, 0x6b, 0x76, 0xf7, 0xa2, 0x44, 0xe2, 0xf3,
	0xf1, 0x39, 0xf8, 0x28, 0x68, 0xff, 0xdd, 0x1f, 0xc5, 0x40, 0x90, 0xfa, 0x62, 0xdf, 0xfc, 0x66,
	0x76, 0xe6, 0xb7, 0x33, 0xbf, 0xdd, 0x05, 0x48, 0xb9, 0xe6, 0xa3, 0x8d, 0x14, 0x5a, 0x90, 0x3d,
	0x89, 0x4a, 0x1f, 0xbf, 0x5e, 0x66, 0x7a, 0x55, 0x2e, 0x46, 0x89, 0x58, 0x8f, 0x37, 0x77, 0x69,
	0x26, 0xc6, 0x09, 0xe6, 0xb9, 0x1a, 0x27, 0x62, 0xbd, 0x16, 0xc5, 0xd8, 0x86, 0x8e, 0xb5, 0x44,
	0xb4, 0x3f, 0x6e, 0xe9, 0xf1, 0x9b, 0x87, 0x2c, 0x4a, 0x45, 0xa2, 0xb4, 0x90, 0x58, 0x7d, 0xb8,
	0xc5, 0xf4, 0x07, 0x78, 0x34, 0x47, 0x2e, 0x93, 0x15, 0x43, 0x55, 0xe6, 0x5a, 0x91, 0x53, 0xd8,
	0xf7, 0x9f, 0x51, 0xe7, 0x64, 0xf7, 0xd5, 0x70, 0x02, 0x23, 0x5b, 0xeb, 0x5c, 0xa4, 0xc8, 0x82,
	0x8b, 0x1c, 0x41, 0xf7, 0x42, 0x68, 0x9e, 0x47, 0x3b, 0x27, 0x9d, 0x57, 0x5d, 0xe6, 0x0c, 0xfa,
	0x57, 0x07, 0x20, 0xe6, 0xcb, 0xac, 0xe0, 0x3a, 0x13, 0x85, 0x09, 0x7a, 0x9f, 0xad, 0x33, 0x1d,
	0x75, 0x5c, 0x90, 0x35, 0xc8, 0x29, 0x3c, 0x9a, 0x96, 0x52, 0x62, 0xa1, 0x3f, 0x5c, 0x5d, 0x29,
	0xd4, 0x3e, 0x45, 0x1b, 0xac, 0x0b, 0xec, 0x36, 0x0a, 0x90, 0x13, 0x18, 0xfa, 0xb0, 0x98, 0x2f,
	0x31, 0xda, 0xb3, 0xbe, 0x26, 0x44, 0x5e, 0x00, 0xd8, 0x50, 0x63, 0xa8, 0xa8, 0x6b, 0x03, 0x1a,
	0x88, 0xf1, 0x9f, 0xe3, 0x6d, 0x28, 0xdd, 0x73, 0xfe, 0x1a, 0x31, 0xfe, 0x58, 0xe2, 0x8d, 0xf7,
	0xef, 0x3b, 0x7f, 0x8d, 0xd0, 0x19, 0xf4, 0x7f, 0x44, 0xcd, 0xcd, 0xe4, 0xc8, 0x73, 0x18, 0x9c,
	0xf3, 0x35, 0xaa, 0x0d, 0x4f, 0xd0, 0xee, 0x71, 0xc0, 0x6a, 0x80, 0x1c, 0x43, 0xff, 0x4c, 0x89,
	0xc2, 0x44, 0xdb, 0x2d, 0x0e, 0x58, 0x65, 0xd3, 0x5f, 0xe0, 0xb1, 0xf9, 0x9f, 0x8a, 0x3c, 0xc7,
	0xc4, 0xf6, 0xea, 0x18, 0xfa, 0xa6, 0xc3, 0x31, 0xd7, 0x2b, 0x9f, 0xaa, 0xb2, 0xc9, 0x17, 0x30,
	0x08, 0x35, 0x55, 0xb4, 0x63, 0x87, 0xf2, 0x78, 0x64, 0xf4, 0x32, 0x0a, 0x30, 0xab, 0x03, 0x68,
	0x0c, 0x47, 0xc6, 0xa8, 0x88, 0x30, 0xfc, 0xbd, 0x44, 0xa5, 0xff, 0xb5, 0x42, 0x6b, 0x27, 0xa6,
	0x42, 0x73, 0x27, 0xf4, 0xcf, 0x0e, 0x90, 0x6f, 0x51, 0xbf, 0x2b, 0xf3, 0x6b, 0x93, 0x39, 0x24,
	0x34, 0x8b, 0x7c, 0x02, 0xa7, 0x15, 0xb3, 0x28, 0x00, 0xc1, 0x7b, 0x59, 0x66, 0xa9, 0xaa, 0x52,
	0x06, 0x80, 0x7c, 0x0e, 0x07, 0x6f, 0xf3, 0xdc, 0x64, 0x8b, 0xa5, 0xb8, 0xc9, 0x52, 0x94, 0xca,
	0x4e, 0xba, 0xcf, 0xee, 0xe1, 0x86, 0xf8, 0xcf, 0x28, 0x55, 0x26, 0x0a, 0x65, 0x27, 0xde, 0x67,
	0x95, 0x4d, 0x9e, 0x42, 0xcf, 0x8f, 0xca, 0x8d, 0xba, 0x57, 0xcb, 0xc7, 0x49, 0xaf, 0xd7, 0x90,
	0x1e, 0xbd, 0x82, 0x83, 0x7a, 0x13, 0x6a, 0x23, 0x0a, 0x85, 0xe4, 0x04, 0xba, 0x86, 0xd6, 0x36,
	0xb5, 0x3b, 0x07, 0xf9, 0xaa, 0x29, 0x6a, 0x5b, 0x67, 0x38, 0x39, 0x70, 0xfd, 0xaf, 0x71, 0xd6,
	0x88, 0xa1, 0x9f, 0xc1, 0x93, 0xef, 0x90, 0xa7, 0x36, 0x89, 0x6f, 0x16, 0x81, 0x3d, 0x63, 0xfa,
	0xce, 0xdb, 0x6f, 0x3a, 0x81, 0x83, 0x3a, 0xcc, 0xd3, 0x79, 0xd1, 0x88, 0x6b, 0xb3, 0x71, 0x6b,
	0x6e, 0x81, 0x4c, 0x25, 0x72, 0x8d, 0x96, 0x5b, 0xc8, 0xfe, 0xdf, 0x9b, 0x78, 0x0e, 0x03, 0x86,
	0x49, 0x29, 0x55, 0x76, 0x83, 0x56, 0x8e, 0x7d, 0x56, 0x03, 0x84, 0xc2, 0x27, 0x17, 0xb8, 0xde,
	0xe4, 0x5c, 0xe3, 0xe5, 0xe5, 0xf7, 0x33, 0x3b, 0x8a, 0x01, 0x6b, 0x61, 0xf4, 0x16, 0x9e, 0xba,
	0xca, 0x73, 0xf4, 0xa2, 0x7d, 0x78, 0x75, 0x93, 0x9f, 0xcb, 0x25, 0xea, 0xb7, 0x76, 0xa1, 0x3f,
	0x0f, 0x2d, 0x8c, 0x44, 0xb0, 0x1f, 0x9b, 0xb1, 0x2a, 0xed, 0x95, 0x10, 0x4c, 0xca, 0xe1, 0xd9,
	0xbd, 0xca, 0xbe, 0x5d, 0xa7, 0xe6, 0xfa, 0xf2, 0xa0, 0x65, 0xee, 0xfa, 0xdb, 0x06, 0x6b, 0x82,
	0x3b, 0xff, 0x40, 0x90, 0xfe, 0x06, 0x4f, 0xec, 0x47, 0xe3, 0x44, 0x52, 0xe8, 0xc5, 0xdc, 0xdc,
	0x2b, 0x5b, 0x66, 0xe1, 0x3d, 0xe4, 0x25, 0xf4, 0xa7, 0xab, 0x2c, 0x4f, 0x25, 0x16, 0x5b, 0x72,
	0x57, 0x3e, 0x7a, 0x01, 0x64, 0x86, 0x39, 0x7e, 0xdc, 0xa9, 0xd1, 0x5f, 0xe1, 0xf0, 0x1d, 0x4f,
	0xae, 0x97, 0x52, 0x94, 0x45, 0x7a, 0x26, 0x16, 0xee, 0x72, 0x36, 0x52, 0x33, 0x87, 0x2c, 0x48,
	0xcd, 0x7c, 0xdb, 0xf3, 0xc0, 0x17, 0x98, 0xfb, 0xce, 0x3b, 0x23, 0x5c, 0x09, 0x36, 0x7a, 0xb7,
	0xbe, 0x12, 0x8c, 0x4d, 0x63, 0x38, 0x6c, 0x51, 0xf6, 0x0d, 0xff, 0x06, 0xc0, 0xc1, 0x67, 0x62,
	0x11, 0x88, 0x7f, 0xea, 0x0e, 0xc3, 0x16, 0x2e, 0xac, 0x11, 0x4c, 0xbf, 0x86, 0x43, 0x86, 0xf6,
	0xed, 0xf9, 0x7f, 0x5d, 0xa0, 0x73, 0x38, 0x6a, 0x2f, 0xf4, 0x5c, 0xde, 0xc0, 0xd0, 0xe3, 0x0f,
	0x23, 0xd3, 0x8c, 0xa6, 0x7f, 0xc0, 0xe1, 0xfb, 0x4c, 0xe9, 0x99, 0x7f, 0x0e, 0x03, 0x9b, 0x08,
	0xf6, 0xe7, 0xc6, 0xae, 0xa4, 0x14, 0x4c, 0xf2, 0x25, 0x74, 0x7f, 0x2a, 0x51, 0xde, 0xd9, 0x16,
	0x0e, 0x27, 0xcf, 0x46, 0xd5, 0x4b, 0x3a, 0x13, 0x49, 0xb9, 0xc6, 0x42, 0x5b, 0x37, 0x73, 0x51,
	0x66, 0x74, 0x53, 0x51, 0x16, 0xfa, 0x43, 0x91, 0xdf, 0x79, 0x41, 0xd7, 0x00, 0x65, 0x40, 0x42,
	0xe5, 0x86, 0xe4, 0x5e, 0xc2, 0x9e, 0x41, 0xfd, 0x4e, 0xc8, 0xfd, 0x0a, 0xcc, 0xfa, 0xdb, 0xaf,
	0xef, 0xae, 0x7f, 0x1c, 0x17, 0x3d, 0xfb, 0xa2, 0xbf, 0xfe, 0x3b, 0x00, 0x00, 0xff, 0xff, 0xec,
	0xe1, 0x88, 0x9c, 0x57, 0x08, 0x00, 0x00,
}
