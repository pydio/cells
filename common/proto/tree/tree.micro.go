// Code generated by protoc-gen-micro. DO NOT EDIT.
// source: tree.proto

/*
Package tree is a generated protocol buffer package.

It is generated from these files:
	tree.proto

It has these top-level messages:
	ReadNodeRequest
	ReadNodeResponse
	ListNodesRequest
	ListNodesResponse
	CreateNodeRequest
	CreateNodeResponse
	UpdateNodeRequest
	UpdateNodeResponse
	DeleteNodeRequest
	DeleteNodeResponse
	IndexationSession
	IndexationOperation
	OpenSessionRequest
	OpenSessionResponse
	FlushSessionRequest
	FlushSessionResponse
	CloseSessionRequest
	CloseSessionResponse
	WatchNodeRequest
	WatchNodeResponse
	SearchRequest
	SearchResponse
	CreateVersionRequest
	CreateVersionResponse
	ListVersionsRequest
	ListVersionsResponse
	HeadVersionRequest
	HeadVersionResponse
	StoreVersionRequest
	StoreVersionResponse
	PruneVersionsRequest
	PruneVersionsResponse
	VersioningPolicy
	VersioningKeepPeriod
	Node
	WorkspaceRelativePath
	ChangeLog
	Query
	GeoQuery
	GeoPoint
	StreamChangesRequest
	NodeChangeEvent
	IndexEvent
	GetEncryptionKeyRequest
	GetEncryptionKeyResponse
	SyncChange
	SyncChangeNode
	PutSyncChangeResponse
	SearchSyncChangeRequest
*/
package tree

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	client "github.com/micro/go-micro/client"
	server "github.com/micro/go-micro/server"
	context "context"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ client.Option
var _ server.Option

// Client API for NodeProvider service

type NodeProviderClient interface {
	ReadNode(ctx context.Context, in *ReadNodeRequest, opts ...client.CallOption) (*ReadNodeResponse, error)
	ListNodes(ctx context.Context, in *ListNodesRequest, opts ...client.CallOption) (NodeProvider_ListNodesClient, error)
}

type nodeProviderClient struct {
	c           client.Client
	serviceName string
}

func NewNodeProviderClient(serviceName string, c client.Client) NodeProviderClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeProviderClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *nodeProviderClient) ReadNode(ctx context.Context, in *ReadNodeRequest, opts ...client.CallOption) (*ReadNodeResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeProvider.ReadNode", in)
	out := new(ReadNodeResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeProviderClient) ListNodes(ctx context.Context, in *ListNodesRequest, opts ...client.CallOption) (NodeProvider_ListNodesClient, error) {
	req := c.c.NewRequest(c.serviceName, "NodeProvider.ListNodes", &ListNodesRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	if err := stream.Send(in); err != nil {
		return nil, err
	}
	return &nodeProviderListNodesClient{stream}, nil
}

type NodeProvider_ListNodesClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Recv() (*ListNodesResponse, error)
}

type nodeProviderListNodesClient struct {
	stream client.Streamer
}

func (x *nodeProviderListNodesClient) Close() error {
	return x.stream.Close()
}

func (x *nodeProviderListNodesClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeProviderListNodesClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeProviderListNodesClient) Recv() (*ListNodesResponse, error) {
	m := new(ListNodesResponse)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for NodeProvider service

type NodeProviderHandler interface {
	ReadNode(context.Context, *ReadNodeRequest, *ReadNodeResponse) error
	ListNodes(context.Context, *ListNodesRequest, NodeProvider_ListNodesStream) error
}

func RegisterNodeProviderHandler(s server.Server, hdlr NodeProviderHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeProvider{hdlr}, opts...))
}

type NodeProvider struct {
	NodeProviderHandler
}

func (h *NodeProvider) ReadNode(ctx context.Context, in *ReadNodeRequest, out *ReadNodeResponse) error {
	return h.NodeProviderHandler.ReadNode(ctx, in, out)
}

func (h *NodeProvider) ListNodes(ctx context.Context, stream server.Streamer) error {
	m := new(ListNodesRequest)
	if err := stream.Recv(m); err != nil {
		return err
	}
	return h.NodeProviderHandler.ListNodes(ctx, m, &nodeProviderListNodesStream{stream})
}

type NodeProvider_ListNodesStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*ListNodesResponse) error
}

type nodeProviderListNodesStream struct {
	stream server.Streamer
}

func (x *nodeProviderListNodesStream) Close() error {
	return x.stream.Close()
}

func (x *nodeProviderListNodesStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeProviderListNodesStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeProviderListNodesStream) Send(m *ListNodesResponse) error {
	return x.stream.Send(m)
}

// Client API for NodeProviderStreamer service

type NodeProviderStreamerClient interface {
	ReadNodeStream(ctx context.Context, opts ...client.CallOption) (NodeProviderStreamer_ReadNodeStreamClient, error)
}

type nodeProviderStreamerClient struct {
	c           client.Client
	serviceName string
}

func NewNodeProviderStreamerClient(serviceName string, c client.Client) NodeProviderStreamerClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeProviderStreamerClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *nodeProviderStreamerClient) ReadNodeStream(ctx context.Context, opts ...client.CallOption) (NodeProviderStreamer_ReadNodeStreamClient, error) {
	req := c.c.NewRequest(c.serviceName, "NodeProviderStreamer.ReadNodeStream", &ReadNodeRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return &nodeProviderStreamerReadNodeStreamClient{stream}, nil
}

type NodeProviderStreamer_ReadNodeStreamClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*ReadNodeRequest) error
	Recv() (*ReadNodeResponse, error)
}

type nodeProviderStreamerReadNodeStreamClient struct {
	stream client.Streamer
}

func (x *nodeProviderStreamerReadNodeStreamClient) Close() error {
	return x.stream.Close()
}

func (x *nodeProviderStreamerReadNodeStreamClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeProviderStreamerReadNodeStreamClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeProviderStreamerReadNodeStreamClient) Send(m *ReadNodeRequest) error {
	return x.stream.Send(m)
}

func (x *nodeProviderStreamerReadNodeStreamClient) Recv() (*ReadNodeResponse, error) {
	m := new(ReadNodeResponse)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for NodeProviderStreamer service

type NodeProviderStreamerHandler interface {
	ReadNodeStream(context.Context, NodeProviderStreamer_ReadNodeStreamStream) error
}

func RegisterNodeProviderStreamerHandler(s server.Server, hdlr NodeProviderStreamerHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeProviderStreamer{hdlr}, opts...))
}

type NodeProviderStreamer struct {
	NodeProviderStreamerHandler
}

func (h *NodeProviderStreamer) ReadNodeStream(ctx context.Context, stream server.Streamer) error {
	return h.NodeProviderStreamerHandler.ReadNodeStream(ctx, &nodeProviderStreamerReadNodeStreamStream{stream})
}

type NodeProviderStreamer_ReadNodeStreamStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*ReadNodeResponse) error
	Recv() (*ReadNodeRequest, error)
}

type nodeProviderStreamerReadNodeStreamStream struct {
	stream server.Streamer
}

func (x *nodeProviderStreamerReadNodeStreamStream) Close() error {
	return x.stream.Close()
}

func (x *nodeProviderStreamerReadNodeStreamStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeProviderStreamerReadNodeStreamStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeProviderStreamerReadNodeStreamStream) Send(m *ReadNodeResponse) error {
	return x.stream.Send(m)
}

func (x *nodeProviderStreamerReadNodeStreamStream) Recv() (*ReadNodeRequest, error) {
	m := new(ReadNodeRequest)
	if err := x.stream.Recv(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Client API for NodeChangesStreamer service

type NodeChangesStreamerClient interface {
	StreamChanges(ctx context.Context, in *StreamChangesRequest, opts ...client.CallOption) (NodeChangesStreamer_StreamChangesClient, error)
}

type nodeChangesStreamerClient struct {
	c           client.Client
	serviceName string
}

func NewNodeChangesStreamerClient(serviceName string, c client.Client) NodeChangesStreamerClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeChangesStreamerClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *nodeChangesStreamerClient) StreamChanges(ctx context.Context, in *StreamChangesRequest, opts ...client.CallOption) (NodeChangesStreamer_StreamChangesClient, error) {
	req := c.c.NewRequest(c.serviceName, "NodeChangesStreamer.StreamChanges", &StreamChangesRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	if err := stream.Send(in); err != nil {
		return nil, err
	}
	return &nodeChangesStreamerStreamChangesClient{stream}, nil
}

type NodeChangesStreamer_StreamChangesClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Recv() (*NodeChangeEvent, error)
}

type nodeChangesStreamerStreamChangesClient struct {
	stream client.Streamer
}

func (x *nodeChangesStreamerStreamChangesClient) Close() error {
	return x.stream.Close()
}

func (x *nodeChangesStreamerStreamChangesClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeChangesStreamerStreamChangesClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeChangesStreamerStreamChangesClient) Recv() (*NodeChangeEvent, error) {
	m := new(NodeChangeEvent)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for NodeChangesStreamer service

type NodeChangesStreamerHandler interface {
	StreamChanges(context.Context, *StreamChangesRequest, NodeChangesStreamer_StreamChangesStream) error
}

func RegisterNodeChangesStreamerHandler(s server.Server, hdlr NodeChangesStreamerHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeChangesStreamer{hdlr}, opts...))
}

type NodeChangesStreamer struct {
	NodeChangesStreamerHandler
}

func (h *NodeChangesStreamer) StreamChanges(ctx context.Context, stream server.Streamer) error {
	m := new(StreamChangesRequest)
	if err := stream.Recv(m); err != nil {
		return err
	}
	return h.NodeChangesStreamerHandler.StreamChanges(ctx, m, &nodeChangesStreamerStreamChangesStream{stream})
}

type NodeChangesStreamer_StreamChangesStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*NodeChangeEvent) error
}

type nodeChangesStreamerStreamChangesStream struct {
	stream server.Streamer
}

func (x *nodeChangesStreamerStreamChangesStream) Close() error {
	return x.stream.Close()
}

func (x *nodeChangesStreamerStreamChangesStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeChangesStreamerStreamChangesStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeChangesStreamerStreamChangesStream) Send(m *NodeChangeEvent) error {
	return x.stream.Send(m)
}

// Client API for NodeReceiver service

type NodeReceiverClient interface {
	CreateNode(ctx context.Context, in *CreateNodeRequest, opts ...client.CallOption) (*CreateNodeResponse, error)
	UpdateNode(ctx context.Context, in *UpdateNodeRequest, opts ...client.CallOption) (*UpdateNodeResponse, error)
	DeleteNode(ctx context.Context, in *DeleteNodeRequest, opts ...client.CallOption) (*DeleteNodeResponse, error)
}

type nodeReceiverClient struct {
	c           client.Client
	serviceName string
}

func NewNodeReceiverClient(serviceName string, c client.Client) NodeReceiverClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeReceiverClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *nodeReceiverClient) CreateNode(ctx context.Context, in *CreateNodeRequest, opts ...client.CallOption) (*CreateNodeResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeReceiver.CreateNode", in)
	out := new(CreateNodeResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeReceiverClient) UpdateNode(ctx context.Context, in *UpdateNodeRequest, opts ...client.CallOption) (*UpdateNodeResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeReceiver.UpdateNode", in)
	out := new(UpdateNodeResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeReceiverClient) DeleteNode(ctx context.Context, in *DeleteNodeRequest, opts ...client.CallOption) (*DeleteNodeResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeReceiver.DeleteNode", in)
	out := new(DeleteNodeResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for NodeReceiver service

type NodeReceiverHandler interface {
	CreateNode(context.Context, *CreateNodeRequest, *CreateNodeResponse) error
	UpdateNode(context.Context, *UpdateNodeRequest, *UpdateNodeResponse) error
	DeleteNode(context.Context, *DeleteNodeRequest, *DeleteNodeResponse) error
}

func RegisterNodeReceiverHandler(s server.Server, hdlr NodeReceiverHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeReceiver{hdlr}, opts...))
}

type NodeReceiver struct {
	NodeReceiverHandler
}

func (h *NodeReceiver) CreateNode(ctx context.Context, in *CreateNodeRequest, out *CreateNodeResponse) error {
	return h.NodeReceiverHandler.CreateNode(ctx, in, out)
}

func (h *NodeReceiver) UpdateNode(ctx context.Context, in *UpdateNodeRequest, out *UpdateNodeResponse) error {
	return h.NodeReceiverHandler.UpdateNode(ctx, in, out)
}

func (h *NodeReceiver) DeleteNode(ctx context.Context, in *DeleteNodeRequest, out *DeleteNodeResponse) error {
	return h.NodeReceiverHandler.DeleteNode(ctx, in, out)
}

// Client API for NodeReceiverStream service

type NodeReceiverStreamClient interface {
	CreateNodeStream(ctx context.Context, opts ...client.CallOption) (NodeReceiverStream_CreateNodeStreamClient, error)
	UpdateNodeStream(ctx context.Context, opts ...client.CallOption) (NodeReceiverStream_UpdateNodeStreamClient, error)
	DeleteNodeStream(ctx context.Context, opts ...client.CallOption) (NodeReceiverStream_DeleteNodeStreamClient, error)
}

type nodeReceiverStreamClient struct {
	c           client.Client
	serviceName string
}

func NewNodeReceiverStreamClient(serviceName string, c client.Client) NodeReceiverStreamClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeReceiverStreamClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *nodeReceiverStreamClient) CreateNodeStream(ctx context.Context, opts ...client.CallOption) (NodeReceiverStream_CreateNodeStreamClient, error) {
	req := c.c.NewRequest(c.serviceName, "NodeReceiverStream.CreateNodeStream", &CreateNodeRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return &nodeReceiverStreamCreateNodeStreamClient{stream}, nil
}

type NodeReceiverStream_CreateNodeStreamClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*CreateNodeRequest) error
	Recv() (*CreateNodeResponse, error)
}

type nodeReceiverStreamCreateNodeStreamClient struct {
	stream client.Streamer
}

func (x *nodeReceiverStreamCreateNodeStreamClient) Close() error {
	return x.stream.Close()
}

func (x *nodeReceiverStreamCreateNodeStreamClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamCreateNodeStreamClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeReceiverStreamCreateNodeStreamClient) Send(m *CreateNodeRequest) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamCreateNodeStreamClient) Recv() (*CreateNodeResponse, error) {
	m := new(CreateNodeResponse)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeReceiverStreamClient) UpdateNodeStream(ctx context.Context, opts ...client.CallOption) (NodeReceiverStream_UpdateNodeStreamClient, error) {
	req := c.c.NewRequest(c.serviceName, "NodeReceiverStream.UpdateNodeStream", &UpdateNodeRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return &nodeReceiverStreamUpdateNodeStreamClient{stream}, nil
}

type NodeReceiverStream_UpdateNodeStreamClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*UpdateNodeRequest) error
	Recv() (*UpdateNodeResponse, error)
}

type nodeReceiverStreamUpdateNodeStreamClient struct {
	stream client.Streamer
}

func (x *nodeReceiverStreamUpdateNodeStreamClient) Close() error {
	return x.stream.Close()
}

func (x *nodeReceiverStreamUpdateNodeStreamClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamUpdateNodeStreamClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeReceiverStreamUpdateNodeStreamClient) Send(m *UpdateNodeRequest) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamUpdateNodeStreamClient) Recv() (*UpdateNodeResponse, error) {
	m := new(UpdateNodeResponse)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeReceiverStreamClient) DeleteNodeStream(ctx context.Context, opts ...client.CallOption) (NodeReceiverStream_DeleteNodeStreamClient, error) {
	req := c.c.NewRequest(c.serviceName, "NodeReceiverStream.DeleteNodeStream", &DeleteNodeRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return &nodeReceiverStreamDeleteNodeStreamClient{stream}, nil
}

type NodeReceiverStream_DeleteNodeStreamClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*DeleteNodeRequest) error
	Recv() (*DeleteNodeResponse, error)
}

type nodeReceiverStreamDeleteNodeStreamClient struct {
	stream client.Streamer
}

func (x *nodeReceiverStreamDeleteNodeStreamClient) Close() error {
	return x.stream.Close()
}

func (x *nodeReceiverStreamDeleteNodeStreamClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamDeleteNodeStreamClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeReceiverStreamDeleteNodeStreamClient) Send(m *DeleteNodeRequest) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamDeleteNodeStreamClient) Recv() (*DeleteNodeResponse, error) {
	m := new(DeleteNodeResponse)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for NodeReceiverStream service

type NodeReceiverStreamHandler interface {
	CreateNodeStream(context.Context, NodeReceiverStream_CreateNodeStreamStream) error
	UpdateNodeStream(context.Context, NodeReceiverStream_UpdateNodeStreamStream) error
	DeleteNodeStream(context.Context, NodeReceiverStream_DeleteNodeStreamStream) error
}

func RegisterNodeReceiverStreamHandler(s server.Server, hdlr NodeReceiverStreamHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeReceiverStream{hdlr}, opts...))
}

type NodeReceiverStream struct {
	NodeReceiverStreamHandler
}

func (h *NodeReceiverStream) CreateNodeStream(ctx context.Context, stream server.Streamer) error {
	return h.NodeReceiverStreamHandler.CreateNodeStream(ctx, &nodeReceiverStreamCreateNodeStreamStream{stream})
}

type NodeReceiverStream_CreateNodeStreamStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*CreateNodeResponse) error
	Recv() (*CreateNodeRequest, error)
}

type nodeReceiverStreamCreateNodeStreamStream struct {
	stream server.Streamer
}

func (x *nodeReceiverStreamCreateNodeStreamStream) Close() error {
	return x.stream.Close()
}

func (x *nodeReceiverStreamCreateNodeStreamStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamCreateNodeStreamStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeReceiverStreamCreateNodeStreamStream) Send(m *CreateNodeResponse) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamCreateNodeStreamStream) Recv() (*CreateNodeRequest, error) {
	m := new(CreateNodeRequest)
	if err := x.stream.Recv(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (h *NodeReceiverStream) UpdateNodeStream(ctx context.Context, stream server.Streamer) error {
	return h.NodeReceiverStreamHandler.UpdateNodeStream(ctx, &nodeReceiverStreamUpdateNodeStreamStream{stream})
}

type NodeReceiverStream_UpdateNodeStreamStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*UpdateNodeResponse) error
	Recv() (*UpdateNodeRequest, error)
}

type nodeReceiverStreamUpdateNodeStreamStream struct {
	stream server.Streamer
}

func (x *nodeReceiverStreamUpdateNodeStreamStream) Close() error {
	return x.stream.Close()
}

func (x *nodeReceiverStreamUpdateNodeStreamStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamUpdateNodeStreamStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeReceiverStreamUpdateNodeStreamStream) Send(m *UpdateNodeResponse) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamUpdateNodeStreamStream) Recv() (*UpdateNodeRequest, error) {
	m := new(UpdateNodeRequest)
	if err := x.stream.Recv(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (h *NodeReceiverStream) DeleteNodeStream(ctx context.Context, stream server.Streamer) error {
	return h.NodeReceiverStreamHandler.DeleteNodeStream(ctx, &nodeReceiverStreamDeleteNodeStreamStream{stream})
}

type NodeReceiverStream_DeleteNodeStreamStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*DeleteNodeResponse) error
	Recv() (*DeleteNodeRequest, error)
}

type nodeReceiverStreamDeleteNodeStreamStream struct {
	stream server.Streamer
}

func (x *nodeReceiverStreamDeleteNodeStreamStream) Close() error {
	return x.stream.Close()
}

func (x *nodeReceiverStreamDeleteNodeStreamStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamDeleteNodeStreamStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeReceiverStreamDeleteNodeStreamStream) Send(m *DeleteNodeResponse) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamDeleteNodeStreamStream) Recv() (*DeleteNodeRequest, error) {
	m := new(DeleteNodeRequest)
	if err := x.stream.Recv(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Client API for SessionIndexer service

type SessionIndexerClient interface {
	OpenSession(ctx context.Context, in *OpenSessionRequest, opts ...client.CallOption) (*OpenSessionResponse, error)
	FlushSession(ctx context.Context, in *FlushSessionRequest, opts ...client.CallOption) (*FlushSessionResponse, error)
	CloseSession(ctx context.Context, in *CloseSessionRequest, opts ...client.CallOption) (*CloseSessionResponse, error)
}

type sessionIndexerClient struct {
	c           client.Client
	serviceName string
}

func NewSessionIndexerClient(serviceName string, c client.Client) SessionIndexerClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &sessionIndexerClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *sessionIndexerClient) OpenSession(ctx context.Context, in *OpenSessionRequest, opts ...client.CallOption) (*OpenSessionResponse, error) {
	req := c.c.NewRequest(c.serviceName, "SessionIndexer.OpenSession", in)
	out := new(OpenSessionResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionIndexerClient) FlushSession(ctx context.Context, in *FlushSessionRequest, opts ...client.CallOption) (*FlushSessionResponse, error) {
	req := c.c.NewRequest(c.serviceName, "SessionIndexer.FlushSession", in)
	out := new(FlushSessionResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionIndexerClient) CloseSession(ctx context.Context, in *CloseSessionRequest, opts ...client.CallOption) (*CloseSessionResponse, error) {
	req := c.c.NewRequest(c.serviceName, "SessionIndexer.CloseSession", in)
	out := new(CloseSessionResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SessionIndexer service

type SessionIndexerHandler interface {
	OpenSession(context.Context, *OpenSessionRequest, *OpenSessionResponse) error
	FlushSession(context.Context, *FlushSessionRequest, *FlushSessionResponse) error
	CloseSession(context.Context, *CloseSessionRequest, *CloseSessionResponse) error
}

func RegisterSessionIndexerHandler(s server.Server, hdlr SessionIndexerHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&SessionIndexer{hdlr}, opts...))
}

type SessionIndexer struct {
	SessionIndexerHandler
}

func (h *SessionIndexer) OpenSession(ctx context.Context, in *OpenSessionRequest, out *OpenSessionResponse) error {
	return h.SessionIndexerHandler.OpenSession(ctx, in, out)
}

func (h *SessionIndexer) FlushSession(ctx context.Context, in *FlushSessionRequest, out *FlushSessionResponse) error {
	return h.SessionIndexerHandler.FlushSession(ctx, in, out)
}

func (h *SessionIndexer) CloseSession(ctx context.Context, in *CloseSessionRequest, out *CloseSessionResponse) error {
	return h.SessionIndexerHandler.CloseSession(ctx, in, out)
}

// Client API for NodeEventsProvider service

type NodeEventsProviderClient interface {
	WatchNode(ctx context.Context, in *WatchNodeRequest, opts ...client.CallOption) (NodeEventsProvider_WatchNodeClient, error)
}

type nodeEventsProviderClient struct {
	c           client.Client
	serviceName string
}

func NewNodeEventsProviderClient(serviceName string, c client.Client) NodeEventsProviderClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeEventsProviderClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *nodeEventsProviderClient) WatchNode(ctx context.Context, in *WatchNodeRequest, opts ...client.CallOption) (NodeEventsProvider_WatchNodeClient, error) {
	req := c.c.NewRequest(c.serviceName, "NodeEventsProvider.WatchNode", &WatchNodeRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	if err := stream.Send(in); err != nil {
		return nil, err
	}
	return &nodeEventsProviderWatchNodeClient{stream}, nil
}

type NodeEventsProvider_WatchNodeClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Recv() (*WatchNodeResponse, error)
}

type nodeEventsProviderWatchNodeClient struct {
	stream client.Streamer
}

func (x *nodeEventsProviderWatchNodeClient) Close() error {
	return x.stream.Close()
}

func (x *nodeEventsProviderWatchNodeClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeEventsProviderWatchNodeClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeEventsProviderWatchNodeClient) Recv() (*WatchNodeResponse, error) {
	m := new(WatchNodeResponse)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for NodeEventsProvider service

type NodeEventsProviderHandler interface {
	WatchNode(context.Context, *WatchNodeRequest, NodeEventsProvider_WatchNodeStream) error
}

func RegisterNodeEventsProviderHandler(s server.Server, hdlr NodeEventsProviderHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeEventsProvider{hdlr}, opts...))
}

type NodeEventsProvider struct {
	NodeEventsProviderHandler
}

func (h *NodeEventsProvider) WatchNode(ctx context.Context, stream server.Streamer) error {
	m := new(WatchNodeRequest)
	if err := stream.Recv(m); err != nil {
		return err
	}
	return h.NodeEventsProviderHandler.WatchNode(ctx, m, &nodeEventsProviderWatchNodeStream{stream})
}

type NodeEventsProvider_WatchNodeStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*WatchNodeResponse) error
}

type nodeEventsProviderWatchNodeStream struct {
	stream server.Streamer
}

func (x *nodeEventsProviderWatchNodeStream) Close() error {
	return x.stream.Close()
}

func (x *nodeEventsProviderWatchNodeStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeEventsProviderWatchNodeStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeEventsProviderWatchNodeStream) Send(m *WatchNodeResponse) error {
	return x.stream.Send(m)
}

// Client API for Searcher service

type SearcherClient interface {
	Search(ctx context.Context, in *SearchRequest, opts ...client.CallOption) (Searcher_SearchClient, error)
}

type searcherClient struct {
	c           client.Client
	serviceName string
}

func NewSearcherClient(serviceName string, c client.Client) SearcherClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &searcherClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *searcherClient) Search(ctx context.Context, in *SearchRequest, opts ...client.CallOption) (Searcher_SearchClient, error) {
	req := c.c.NewRequest(c.serviceName, "Searcher.Search", &SearchRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	if err := stream.Send(in); err != nil {
		return nil, err
	}
	return &searcherSearchClient{stream}, nil
}

type Searcher_SearchClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Recv() (*SearchResponse, error)
}

type searcherSearchClient struct {
	stream client.Streamer
}

func (x *searcherSearchClient) Close() error {
	return x.stream.Close()
}

func (x *searcherSearchClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *searcherSearchClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *searcherSearchClient) Recv() (*SearchResponse, error) {
	m := new(SearchResponse)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Searcher service

type SearcherHandler interface {
	Search(context.Context, *SearchRequest, Searcher_SearchStream) error
}

func RegisterSearcherHandler(s server.Server, hdlr SearcherHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&Searcher{hdlr}, opts...))
}

type Searcher struct {
	SearcherHandler
}

func (h *Searcher) Search(ctx context.Context, stream server.Streamer) error {
	m := new(SearchRequest)
	if err := stream.Recv(m); err != nil {
		return err
	}
	return h.SearcherHandler.Search(ctx, m, &searcherSearchStream{stream})
}

type Searcher_SearchStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*SearchResponse) error
}

type searcherSearchStream struct {
	stream server.Streamer
}

func (x *searcherSearchStream) Close() error {
	return x.stream.Close()
}

func (x *searcherSearchStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *searcherSearchStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *searcherSearchStream) Send(m *SearchResponse) error {
	return x.stream.Send(m)
}

// Client API for NodeContentReader service

type NodeContentReaderClient interface {
}

type nodeContentReaderClient struct {
	c           client.Client
	serviceName string
}

func NewNodeContentReaderClient(serviceName string, c client.Client) NodeContentReaderClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeContentReaderClient{
		c:           c,
		serviceName: serviceName,
	}
}

// Server API for NodeContentReader service

type NodeContentReaderHandler interface {
}

func RegisterNodeContentReaderHandler(s server.Server, hdlr NodeContentReaderHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeContentReader{hdlr}, opts...))
}

type NodeContentReader struct {
	NodeContentReaderHandler
}

// Client API for NodeContentWriter service

type NodeContentWriterClient interface {
}

type nodeContentWriterClient struct {
	c           client.Client
	serviceName string
}

func NewNodeContentWriterClient(serviceName string, c client.Client) NodeContentWriterClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeContentWriterClient{
		c:           c,
		serviceName: serviceName,
	}
}

// Server API for NodeContentWriter service

type NodeContentWriterHandler interface {
}

func RegisterNodeContentWriterHandler(s server.Server, hdlr NodeContentWriterHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeContentWriter{hdlr}, opts...))
}

type NodeContentWriter struct {
	NodeContentWriterHandler
}

// Client API for NodeVersioner service

type NodeVersionerClient interface {
	CreateVersion(ctx context.Context, in *CreateVersionRequest, opts ...client.CallOption) (*CreateVersionResponse, error)
	StoreVersion(ctx context.Context, in *StoreVersionRequest, opts ...client.CallOption) (*StoreVersionResponse, error)
	ListVersions(ctx context.Context, in *ListVersionsRequest, opts ...client.CallOption) (NodeVersioner_ListVersionsClient, error)
	HeadVersion(ctx context.Context, in *HeadVersionRequest, opts ...client.CallOption) (*HeadVersionResponse, error)
	PruneVersions(ctx context.Context, in *PruneVersionsRequest, opts ...client.CallOption) (*PruneVersionsResponse, error)
}

type nodeVersionerClient struct {
	c           client.Client
	serviceName string
}

func NewNodeVersionerClient(serviceName string, c client.Client) NodeVersionerClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeVersionerClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *nodeVersionerClient) CreateVersion(ctx context.Context, in *CreateVersionRequest, opts ...client.CallOption) (*CreateVersionResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeVersioner.CreateVersion", in)
	out := new(CreateVersionResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeVersionerClient) StoreVersion(ctx context.Context, in *StoreVersionRequest, opts ...client.CallOption) (*StoreVersionResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeVersioner.StoreVersion", in)
	out := new(StoreVersionResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeVersionerClient) ListVersions(ctx context.Context, in *ListVersionsRequest, opts ...client.CallOption) (NodeVersioner_ListVersionsClient, error) {
	req := c.c.NewRequest(c.serviceName, "NodeVersioner.ListVersions", &ListVersionsRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	if err := stream.Send(in); err != nil {
		return nil, err
	}
	return &nodeVersionerListVersionsClient{stream}, nil
}

type NodeVersioner_ListVersionsClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Recv() (*ListVersionsResponse, error)
}

type nodeVersionerListVersionsClient struct {
	stream client.Streamer
}

func (x *nodeVersionerListVersionsClient) Close() error {
	return x.stream.Close()
}

func (x *nodeVersionerListVersionsClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeVersionerListVersionsClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeVersionerListVersionsClient) Recv() (*ListVersionsResponse, error) {
	m := new(ListVersionsResponse)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeVersionerClient) HeadVersion(ctx context.Context, in *HeadVersionRequest, opts ...client.CallOption) (*HeadVersionResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeVersioner.HeadVersion", in)
	out := new(HeadVersionResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeVersionerClient) PruneVersions(ctx context.Context, in *PruneVersionsRequest, opts ...client.CallOption) (*PruneVersionsResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeVersioner.PruneVersions", in)
	out := new(PruneVersionsResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for NodeVersioner service

type NodeVersionerHandler interface {
	CreateVersion(context.Context, *CreateVersionRequest, *CreateVersionResponse) error
	StoreVersion(context.Context, *StoreVersionRequest, *StoreVersionResponse) error
	ListVersions(context.Context, *ListVersionsRequest, NodeVersioner_ListVersionsStream) error
	HeadVersion(context.Context, *HeadVersionRequest, *HeadVersionResponse) error
	PruneVersions(context.Context, *PruneVersionsRequest, *PruneVersionsResponse) error
}

func RegisterNodeVersionerHandler(s server.Server, hdlr NodeVersionerHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeVersioner{hdlr}, opts...))
}

type NodeVersioner struct {
	NodeVersionerHandler
}

func (h *NodeVersioner) CreateVersion(ctx context.Context, in *CreateVersionRequest, out *CreateVersionResponse) error {
	return h.NodeVersionerHandler.CreateVersion(ctx, in, out)
}

func (h *NodeVersioner) StoreVersion(ctx context.Context, in *StoreVersionRequest, out *StoreVersionResponse) error {
	return h.NodeVersionerHandler.StoreVersion(ctx, in, out)
}

func (h *NodeVersioner) ListVersions(ctx context.Context, stream server.Streamer) error {
	m := new(ListVersionsRequest)
	if err := stream.Recv(m); err != nil {
		return err
	}
	return h.NodeVersionerHandler.ListVersions(ctx, m, &nodeVersionerListVersionsStream{stream})
}

type NodeVersioner_ListVersionsStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*ListVersionsResponse) error
}

type nodeVersionerListVersionsStream struct {
	stream server.Streamer
}

func (x *nodeVersionerListVersionsStream) Close() error {
	return x.stream.Close()
}

func (x *nodeVersionerListVersionsStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeVersionerListVersionsStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeVersionerListVersionsStream) Send(m *ListVersionsResponse) error {
	return x.stream.Send(m)
}

func (h *NodeVersioner) HeadVersion(ctx context.Context, in *HeadVersionRequest, out *HeadVersionResponse) error {
	return h.NodeVersionerHandler.HeadVersion(ctx, in, out)
}

func (h *NodeVersioner) PruneVersions(ctx context.Context, in *PruneVersionsRequest, out *PruneVersionsResponse) error {
	return h.NodeVersionerHandler.PruneVersions(ctx, in, out)
}

// Client API for FileKeyManager service

type FileKeyManagerClient interface {
	GetEncryptionKey(ctx context.Context, in *GetEncryptionKeyRequest, opts ...client.CallOption) (*GetEncryptionKeyResponse, error)
}

type fileKeyManagerClient struct {
	c           client.Client
	serviceName string
}

func NewFileKeyManagerClient(serviceName string, c client.Client) FileKeyManagerClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &fileKeyManagerClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *fileKeyManagerClient) GetEncryptionKey(ctx context.Context, in *GetEncryptionKeyRequest, opts ...client.CallOption) (*GetEncryptionKeyResponse, error) {
	req := c.c.NewRequest(c.serviceName, "FileKeyManager.GetEncryptionKey", in)
	out := new(GetEncryptionKeyResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for FileKeyManager service

type FileKeyManagerHandler interface {
	GetEncryptionKey(context.Context, *GetEncryptionKeyRequest, *GetEncryptionKeyResponse) error
}

func RegisterFileKeyManagerHandler(s server.Server, hdlr FileKeyManagerHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&FileKeyManager{hdlr}, opts...))
}

type FileKeyManager struct {
	FileKeyManagerHandler
}

func (h *FileKeyManager) GetEncryptionKey(ctx context.Context, in *GetEncryptionKeyRequest, out *GetEncryptionKeyResponse) error {
	return h.FileKeyManagerHandler.GetEncryptionKey(ctx, in, out)
}

// Client API for SyncChanges service

type SyncChangesClient interface {
	Put(ctx context.Context, opts ...client.CallOption) (SyncChanges_PutClient, error)
	Search(ctx context.Context, in *SearchSyncChangeRequest, opts ...client.CallOption) (SyncChanges_SearchClient, error)
}

type syncChangesClient struct {
	c           client.Client
	serviceName string
}

func NewSyncChangesClient(serviceName string, c client.Client) SyncChangesClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &syncChangesClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *syncChangesClient) Put(ctx context.Context, opts ...client.CallOption) (SyncChanges_PutClient, error) {
	req := c.c.NewRequest(c.serviceName, "SyncChanges.Put", &SyncChange{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return &syncChangesPutClient{stream}, nil
}

type SyncChanges_PutClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*SyncChange) error
}

type syncChangesPutClient struct {
	stream client.Streamer
}

func (x *syncChangesPutClient) Close() error {
	return x.stream.Close()
}

func (x *syncChangesPutClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *syncChangesPutClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *syncChangesPutClient) Send(m *SyncChange) error {
	return x.stream.Send(m)
}

func (c *syncChangesClient) Search(ctx context.Context, in *SearchSyncChangeRequest, opts ...client.CallOption) (SyncChanges_SearchClient, error) {
	req := c.c.NewRequest(c.serviceName, "SyncChanges.Search", &SearchSyncChangeRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	if err := stream.Send(in); err != nil {
		return nil, err
	}
	return &syncChangesSearchClient{stream}, nil
}

type SyncChanges_SearchClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Recv() (*SyncChange, error)
}

type syncChangesSearchClient struct {
	stream client.Streamer
}

func (x *syncChangesSearchClient) Close() error {
	return x.stream.Close()
}

func (x *syncChangesSearchClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *syncChangesSearchClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *syncChangesSearchClient) Recv() (*SyncChange, error) {
	m := new(SyncChange)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for SyncChanges service

type SyncChangesHandler interface {
	Put(context.Context, SyncChanges_PutStream) error
	Search(context.Context, *SearchSyncChangeRequest, SyncChanges_SearchStream) error
}

func RegisterSyncChangesHandler(s server.Server, hdlr SyncChangesHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&SyncChanges{hdlr}, opts...))
}

type SyncChanges struct {
	SyncChangesHandler
}

func (h *SyncChanges) Put(ctx context.Context, stream server.Streamer) error {
	return h.SyncChangesHandler.Put(ctx, &syncChangesPutStream{stream})
}

type SyncChanges_PutStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Recv() (*SyncChange, error)
}

type syncChangesPutStream struct {
	stream server.Streamer
}

func (x *syncChangesPutStream) Close() error {
	return x.stream.Close()
}

func (x *syncChangesPutStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *syncChangesPutStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *syncChangesPutStream) Recv() (*SyncChange, error) {
	m := new(SyncChange)
	if err := x.stream.Recv(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (h *SyncChanges) Search(ctx context.Context, stream server.Streamer) error {
	m := new(SearchSyncChangeRequest)
	if err := stream.Recv(m); err != nil {
		return err
	}
	return h.SyncChangesHandler.Search(ctx, m, &syncChangesSearchStream{stream})
}

type SyncChanges_SearchStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*SyncChange) error
}

type syncChangesSearchStream struct {
	stream server.Streamer
}

func (x *syncChangesSearchStream) Close() error {
	return x.stream.Close()
}

func (x *syncChangesSearchStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *syncChangesSearchStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *syncChangesSearchStream) Send(m *SyncChange) error {
	return x.stream.Send(m)
}
